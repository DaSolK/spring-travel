
# Chapter 01 정리  
  
1-1 초난감 DAO
----------------------------------------------------------------------------
UserDao code : DB connect, sql statement, query 실행, query 실행결과 반환,  DB disconnect(자원정리), 예외처리 코드, 테스트코드 모두 포함
=> 데이터 등록, 조회 정상적으로 수행 됨

1-2 DAO 분리
---------------------------------------------------------------------------
1-1의 UserDao 코드가 정상적으로 동작하지만 분리와 확장을 고려한 설계가 아니다.
* 관심이 같은 것 끼리는 하나의 객체 또는 친한 객체(상속관계, 포함관계등)로 모이게 하고, 관심이 다른 것들은 가능한 다 따로 떨어져서 서로 영향을 주지 않도록 분리해야한다. (Separation of Concerns)
* 결합도는 낮추고, 응집도는 높히는 작업

1-1의 UserDao코드에 묶여있는 여러가지 관심사항
1. DB connection
2. sql statement
3. DB disconnection

* 먼저 DB connection을 extract method를 통해 refactoring 하자.
* UserDao 코드에 DB connection 얻어오는 부분을 getConnection 메소드로 추출
=> 관심에 따라 코드를 분리해 놓았기 때문에 한가지 관심에 대한 변경이 일어날 경우 그 관심이 집중되는 부분의 코드만 수정하면 된다.

UserDao 코드를 다른 사용자에게 제공하지 않으면서 getConnection 메소드만 수정하게 할 수 없을까?
* UserDao를 getConnection abstract 메소드를 가지는 abstract class로 만들고, 이를 상속하는 NUserDao, DUserDao류의 class를 만들어 사용한다.

**슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상메소드나 오버라이딩 가능한 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 template method pattern 이라고 한다.**
 (변하지 않는 기능은 슈퍼클래스에, 자주 변경되어 확장할 기능은 서브클래스에 만든다. 슈퍼클래스에서 미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의해 두고, 이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만든다. 슈퍼클래스에서 디폴트 기능을 정의해두거나 비웠다가 서브클래스에서 선택적으로 오버라이드 할 수 있도록 만들어둔 메소드를 hock method 라고 한다.)
**서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 방법을 factory method pattern 이라고 한다.**
(서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드라고 하고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법을 팩토리 메소드 패턴이라고 한다.)
=> 68p 그림1-2가 위 두 패턴이 적용된 클래스 다이어그램을 보여주고 있다.

cf) 디자인 패턴
디자인 패턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션, 패턴의 설계 구조를 보면 대부분 비슷한데, 그 이유는 객체지향적인 설계로부터 문제를 해결하기 위해 적용할 수 있는 확장성 추구 방법이 대부분 클래스 상속, 오브젝트 합성 이라는 두가지 구조로 정리되기 때문이다. 패턴에서 핵심은 패턴의 목적 또는 의도이다. 패턴을 적용할 상황, 해결해야 할 문제, 솔루션의 구조와 각 요소의 역할과 함께 핵심 의도가 무엇인지 기억해둬야 한다.

1-2 DAO 분리 하였지만 남아있는 문제점?
=> 상속관계는 여전히 두 가지 다른 관심사에 대해 긴밀한 결합을 허용한다
ex) 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있음, 클래스는 이중상속을 허용하지 않기 때문에 추후 다른목적으로 UserDao에 상속 적용하기 어렵다.

1-3 DAO의 확장
---------------------------------------------------------------------------
추상 클래스를 만들고 이를 상속한 서브클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있게 만든 이유는 바로 이렇게 변화의 성격이 다른 것을 분리해서, 서로 영향을 주지 않은 채로 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서다. **그러나 단점이 많은 상속이라는 방법을 사용했다**
=> DB connection 과 관련된 부분을 서브클래스가 아니라 아예 별도의 클래스에 담고, 이렇게 만든 클래스를 UserDao가 사용하게 한다.

코드로 보면 아래와 같은 형태이다.

public class UserDao {
	private SimpleConnectionMaker simpleConnectionMaker;
	public UserDao() {
	this.simpleConnectionMaker = new SimpleConnectionMaker ();
}

public void add(User user) throws ClassNotFoundException, SQLExcepion {
	Connection c = simpleConnectionMaker.makeNewConnection();
	...
}

public void get(String id) throws ClassNotFoundException, SQLExcepion {
	Connection c = simpleConnectionMaker.makeNewConnection();
}

}

public class SimpleConnectionMaker {
public Connection makeNewConnection() throwsClassNotFoundException, SQLExcepion {
...
}
}

문제점?
1. UserDao가 simpleConnectionMaker의 makeNewConnection이라는 메소드에 디팬던시가 걸려있다.
2. DB커넥션을 제공하는 클래스가 구체적으로 어떤 클레스인지 UserDao가 알고 있는 구조이다.

=> 인터페이스를 적용하여 구현 클래스에 대한 구체적인 정보를 감추자!
=> 오브젝트 생성과정에서 구현 클래스를 선택해야겠지만, 이외의 부분은 인터페이스로 추상화 해놓은 최소한의 통로를 통해 접근하는 쪽에서는 어떤 클래스를 사용할지 몰라도 된다.

문제점
1. UserDao의 다른 모든 곳에서는 인터페이스를 통해 사용하게 만들어서 DB connection을 제공하는 클래스에 대한 구체적인 정보를 제거 가능하지만, 초기에 오브젝트를 생성하는 과정에서 생성자 코드는 제거되지 않고 남아있다.

=> UserDao 오브젝트가 다른 오젝트와 관계를 맺으려면 관계를 맺을 오브젝트가 있어야 하는데, 이 오브젝트를 UserDao 코드내에서 만들지 말고 메소드 파라미터를 이용해서 외부에서 잔달받자! 즉, **클래스 사이에서 관계를 만들지 말고 오브젝트 사이에서 관계를 만들자**  런타임에 오브젝트 관계를 갖는 구조로 만들어주는것이 클라이언트 코드(여기서는 UserDaoTest)의 책임이다.
(클래스 사이의 관계는 코드에 다른 클래스 이름이 나타나면서 만들어지지만, 오브젝트 사이의 관계는 그렇지 않다.)

객체지향 원칙
* Open-Closed Principle: 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
* High coherence: 응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변화는 부분이 크다는 것을 의미한다.
* Low coupling: 하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 유지하는 정도를 의미한다. (책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다. 느슨한 연결은 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 독립적이고 알 필요도 없게 만들어 준다.)
* 이외에도 SOLID라 불리는 Single-Responsibility Principle, Open-Closed Principle,Liskov-Substitution Principle, Interface-Segregation Principle, Dependency Inversion Principle 등이 있다.

패턴
* strategy pattern: 자식의 context에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스 등을 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용하는 디자인 패턴
ex) UserDao를 사용하는 UserDaoTest는 UserDao가 사용할 전략인 ConnectionMaker를 UserDao의 생성자 또는 setter를 통해 제공해준다.
* factory method pattern: 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 디자인 패턴
* template method pattern: 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상메소드나 오버라이딩 가능한 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 패턴

=> **스프링이란 이런 객체지향 설계원칙과 디자인 패턴에 나타난 장점을 개발자들이 자연스럽게 활용할 수 있도록 도와주는 프레임워크**

1-4 제어의 역전(IoC)
---------------------------------------------------------------------------

factory: 객체의 생성 방법을 결정하고 만들어진 오브젝트를 반환해주는 오브젝트 (디자인 패턴 중 하나인 factory method pattern과 다른 용어, 단순히 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽으로 역할과 책임을 분리하는 목적으로 사용하는 것이  factory이다.)

그림 1-8을 보면 factory를 사용함으로서 어플리케이션 컴포넌트 역할을 하는 오브젝트와 어플리케이션 구조를 결정하는 오브젝트를 분리하였다는 것을 확인할 수 있다.

일반적인 프로그램 흐름은 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 오브젝트를 만들지 결정한다. 즉 모든 종류의 작업을 사용하는 쪽에서 제어한다. **제어의 역전이란 이런 제어의 흐름을 뒤집어 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않고 생성하지도 않는다. 오브젝트 자신 역시 어디서 생성되고 사용되는지 알 수 없다. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임한다.** 

라이브러리는 사용하는 쪽에서 어플리케이션 흐름을 직접 제어하지만, 프레임워크는 어플리케이션 코드가 프레임워크에 의해 사용된다.

1-5 스프링의 IoC
---------------------------------------------------------------------------

스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(Bean) 이라고 부른다. 즉 스프링빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 IoC가 적용된 오브젝트를 가르키는 말이다.

스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리(bean factory)라고 부른다. 빈 팩토리를 조금 더 확장한 어플리케이션 컨텍스트라는 것이 있는데, 어플리케이션 컨텍스트는 IoC 방식을 따라 만들어진 일종의 빈 팩토리다.
빈 팩토리와 어플리케이션 컨텍스트는 거의 동일한 개념이고, 빈 팩토리라고 부를떄는 IoC의 기본 기능(빈의 생성과 관계설정)에 초점을 맞춘것이고, 어플리케이션 콘텍스트라고 부를때는 모든 구성요소의 제어작업을 담당하는 IoC 엔진으로서의 기능에 초점을 맞춘 것이다.

어플리케이션 콘텍스트는 설정정보(여기서는 DaoFactory)를 가져와 빈의 생성, 관계설정 등의 제어작업을 총괄하는 IoC 컨테이너이다.

DaoFactory를 어플리케이션 콘텍스트에서 사용하기 위한 설정정보로 만들기 위해서 @Configuration 어노테이션을 달아 어플리케이션 콘텍스트가 사용할 설정정보 클래스라고 명시한다.
그리고, 오브젝트를 반환하는 메소드(userDao, connectionMaker)에 @Bean 어노테이션을 달아 오브젝트 생성을 담당하는 IoC용 메소드라고 명시한다.

@Configuration 어노테이션이 붙은 자바 코드를 설정정보로 사용하기 위해 ApplicationConfigurationContext를 이용하여 다음과 같이 어플리케이션 콘텍스트를 생성한다.
ApplicationContext context = new ApplicationConfigurationContext(DaoFactory.class);

getBean메소드는 ApplicationConetext가 관리하는 오브젝트를 요청하는 메소드이다. 첫번째 파라미터는 ApplicationConetext에 등록된 빈 이름(설정클래스의 메소드 이름이 빈의 이름이 된다), 두번째 파라미터는 빈의 클래스 타입이다.
특정 클래스를 생성하는 방식이나 구성을 다르게 하는 메소드를 추가하면 메소드 이름을 다르게하여 새로운 빈 이름으로 빈을 만들고 이를 주입해서 사용하면 된다.

오브젝트 팩토리를 이용하여 IoC적용한 방식 / 스프링 어플리케이션 컨텍스트를 이용하여 IoC적용한 방식의 차이점
 * 오브젝트 팩토리를 이용하여 IoC적용한 방식: 코드에서 명시한 제한적인 역할을 함, 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 있음,
 * 스프링 어플리케이션 컨텍스트를 이용하여 IoC적용한 방식: IoC를 적용해서 관리한 모든 오브젝트에 대한 생성과 관계설정을 담당함, 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 없고 생성정보와 연관관계 정보를 별도의 설정정보를 통해 얻음

어플리케이션 컨텍스트를 이용했을때의 장점
 * 클라이언트틑 구체적인 팩트리 클래스를 알 필요가 없다: 오브젝트 팩토리를 이용하면 클라이언트가 필요한 오브젝트를 가져오려면 어떤 팩트리 클래스를 사용하는지 알아야하고, 필요할때마다 팩토리 오브젝트를 생성해야 하지만 어플리케이션 컨텍스트를 이용하면 오브젝트 팩토리가 아무리 많아져도 이를 알거나 직접사용할 필요 없이 일관된 방식(자바코드 또는 xml코드로 된 설정정보에서 얻어오는 방식)을 통해 원하는 오브젝트를 가져올 수 있다.
 * 종합 IoC 서비스를 제공해준다: 오브젝트 생성과 다른 오브젝트와의 관계설정 뿐만 아니라 오브젝트가 만들어지는 방식, 시점, 자동생성, 후처리, 조합, 설정 방식 다변화, 인터셉팅 등등.. 오브젝트를 효과적으로 사용할 다양한 기능을 제공한다
 * 빈을 검색하는 다양한 방법을 제공해준다: getBean 메소드는 빈을 타입만으로 검색하거나 특정 어노테이션 설정이 되어있는 빈을 찾아주기도 한다.

용어정리
 * 빈(bean): 스프링이 IoC 방식으로 관리하는 오브젝트 (스프링이 사용하는 모든 오브젝트가 다 빈은 아니고, 직접 생성과 제어를 담당하는 오브젝트만을 빈이라고 한다)
 * 빈 팩토리(bean factory): 스프링 IoC를 담당하는 컨테이너 빈을 생성, 등록, 조회, 관리 하는 기능을 담당한다. (보통은 빈 팩토리를 바로 사용하지 않고 이를 확장한 어플리케이션 컨텍스트를 이용한다)
 * 어플리케이션 컨텍스트(application context): 빈 팩토리를 확장한 Ioc 컨테이너 빈을 생성, 등록, 조회, 관리 하는 기본기능은 빈 팩토리와 동일하지만 스프링이 제공하는 각종 부가서비스를 추가로 제공
 * 설정정보(configuration metadata): 어플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 설정정보
 * 컨테이너(container): IoC방식으로 빈을 관리한다는 의미에서 어플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너 라고 한다.
 * 스프링 프레임워크(spring framework): IoC 컨테이너, 어플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 뜻함
 
 1-6 싱글톤 레제스트리와 오브젝트 스코프
 ---------------------------------------------------------------------------
