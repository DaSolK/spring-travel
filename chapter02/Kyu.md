
# Chapter 02 정리  

2-1 UserDaoTest 다시보기
----------------------------------------------------------------------------

테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서 만든 코드를 확신할 수 있게 해주는 작업이다.

기존 테스트코드의 특징
 * main 메소드를 이용해 쉽게 테스트 수행 가능
 * 테스트할 대상인 UserDao를 직접 호출해서 사용함
 * 테스트에 사용할 값을 직접 코드에서 만들어 줌
 * 테스트 결과를 콘솔을 통해 확인함
 
 웹을 통한 DAO 테스트 방법의 문제점
 * 서비스 계층, MVC 프리젠테이션 계층 등등을 테스트 결과가 확인가능하게 대충이라도 만들어야 함
 * 테스트 실행과정이 너무 번거로움
 * 에러가 발생했을때 테스트하고자 한 코드에서 문제가 발생했는지, 다른 코드에서 문제가 발생했는지 확인하기 번거로움
 
 => 테스트하고 싶었던 건 UserDao였는데 다른 계층의 코드와 컴포넌트 서버의 설정 상태 까지 모두 테스트에 영향을 줄 수 있기 때문에 이런 방식으로 테스트하는 것은 번거롭고, 오류가 있을때도 빠르게 대응하기 어려움
 
 테스트하고자 하는 대상이 명학하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다. 한꺼번에 너무 많은것을 몰아서 테스트하면 테스트 수행과정도 복잡해지고, 오류가 발생했을 때 정확한 원인을 찾기가 힘들다.
 
 => 테스트는 가능한 작은 단위로 쪼개서 집중 할 수 있어야 한다.
 
 작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트(Unit Test)라고 한다. 여기서 말하는 단위는 정확한 기준이 없다. 다만, 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위를 단위라고 본다.
 
 UserDaoTest의 특징으로 테스트할 데이터가 코드를 통해 제공되고, 테스트 작업 역시 코드를 통해 자동으로 실행한다는 것이 있었는데, 테스트 값을 직접입력 해야하거나 수동으로 테스트를 수행해야한다면 테스트 수행이 부담이 될 수 있다.
 즉, 테스트는 자동으로 수행되도록 코드로 만들어 두는 것이 중요하고, 복잡성을 줄이기 위해 어플리케이션을 구성하는 클래스 안에 테스트코드를 포함시키기 보다는 별도로 테스트용 클래스를 만들어 운용하는 것이 좋다.
 
 테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐만 아니라, 기존에 만들어두었던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 정상동작하는지 확인할 수 있기 때문에 지속적인 개선과 점진적인 개발을 위해서 필요하다.
 
 UserDaoTest의 문제점
  * 테스트 결과가 콘솔로 출력되고 이를 확인하는 것은 사람이 직접 해야한다.
  * main 메소드를 매번 실행해야 하고 DAO가 여러개가 되면 테스트를 위해 매 DAO마다 main을 하나씩 실행해야 한다.
  
  2-2 UserDaoTest 개선
  ----------------------------------------------------------------------------
  
  테스트 검증의 자동화
  
  테스트 결과는 성공/실패로 나눌 수 있고, 실패의 경우는 에러가 발생해서 실패/결과가 다르게 나와 실패로 나눌 수 있다.
  에러가 발생해서 실패한 경우는 에러메세지와 호출스택이 출력될 것이기 때문에 성공/결과가 다르게 나와 실패를 조건문으로 구분한다.
  
  => 값을 하나하나 확인할 필요 없이 "테스트 성공" 이라는 메세지가 출력되는지만 확인하면 되게 수정
  
  테스트의 효율적인 수행과 결과 관리
  
  main 메소드를 이용한 테스트 방법만으로는 어플리케이션 규모가 커지고 테스트 개수가 많아지면 테스트를 수행하는 일이 점점 부담이 될 것이다.
  
  => JUnit 이라는 프레임워크를 사용하자. 
 
 기존에 만들었던 main 메소드 테스트는 제어의 흐름을 가지고 있기 때문에 프레임워크에 적용하기에 적합하지 않다. 테스트가 main 메소드로 만들어졌다는 건 제어권을 직접 갖는다는 의미이기 때문이다.
 JUnit 프레임워크가 요구하는 두가지 조건에 맞추어 main 메소드를 활용한 테스트코드를 옮기자. 두가지 조건은 @Test 어노테이션을 적용할 것과 public 접근자를 가질것 이다.
 
 테스트 결과를 검증하는 조건문(if/else if/else)을 JUnit이 제공해주는 assetThat이라는 스태틱 메소드로 변경한다.
 
 마지막으로 main 메소드에 JUnitCore 클래스의 main메소드를 호출해주는 코드를 넣어주면 실행된다.
 => JUintCore.main("패키지명.UserDaoTest");
 
   2-3 개발자를 위한 테스팅 프레임 워크 JUnit
   ----------------------------------------------------------------------------
   
   Junit 은 사실상 자바의 표준 테스팅 프레임 워크
   
   Junit 테스트 실행 방법? => IDE에 내장된 JUnit 테스트 지원 도구를 사용한다. => 테스트를 실행하고 테스트 결과(총 수행시간, 수행한 테스트 케이스의 수, 성공/실패 케이스의 수)를 보기좋게 정리해준다.
   
   JUnit 테스트의 실행과 그 결과를 확인하는 방법이 매우 간단하고 직관적이며 소스와 긴밀하게 연동해서 결과를 볼 수 있기 때문에, 개발 중에 테스트를 실행하고자 할 때 IDE의 지원을 받는 것이 가장 편리하다.
   
   반복적으로 테스트를 수행했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 할 수 없다.
   
   단위 테스트는 코드가 바뀌지 않는다면 매번 실행할 때마다 동일한 테스트 결과를 얻을 수 있어야 한다. (DB의 데이터와 같은 외부 환경 뿐만 아니라 단위 테스트의 실행 순서에도 영향을 받지 않아야 한다.)
   
   @Test 어노테이션의 exepected 엘리먼트에 발생하리라 기대하는 예외 클래스를 지정하면 예상한 예외 발생없이 해당 테스트케이스를 마치면 테스트가 실패하고, 예상한 예외가 던져지면 테스트가 성공한다.
   
   평소에는 정상적으로 동작하는 것 처럼 보이지만 특별한 상황이 되면 엉뚱하게 동작하논 코드를 만들었는데 테스트를 안 해봤다면 나중에 문제가 발생헀을때 원인을 찾기 힘들다.
   
   개발자들이 곧잘 하는 실수가 테스트케이스를 만들때 성공하는 테스트케이스만 골라서 만든다는 것 => 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관들 들이는게 좋다.
   
   
   "TDD(Test Driven Development)" : 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법
   
   => 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다는 것이 TDD의 원칙 => 이 원칙을 항상 따르면 모든 코드는 빠짐없이 테스트로 검증된 것이다.
   
   TDD는 아예 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만들기 때문에 테스트를 빼먹지 않고 만들 수 있다는 장점이 있다. 
   
   TDD에서는 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 짧게 가져가도록 권장한다. => 개발한 코드의 오류는 빨리 발견할 수록 대응이 쉽게 때문 => 테스트 없이 한번에 너무 많은 코드를 만드는것은 좋지 않다.
   
   JUnit이 테스트 클래스를 가져와 테스트를 수행하는 방식
   1. 테스트 클래스에서 @Test public void 메소드명() 형태의 테스트 메소드를 모두 찾는다.
   2. 테스트 클래스의 오브젝트를 하나 만든다.
   3. @Before가 붙은 메소드가 있으면 실행한다.
   4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장한다
   5. @After가 붙은 메소드가 있으면 실행한다.
   6. 2~5 반복
   7. 결과 종합하여 반환
   
   => @Before에서 @Test의 공통적인 준비작업, @After에서 @Test의 공통적인 정리작업을 수행해주면 좋다.
   
   주의사항! 각 테스트 메소드를 실행할 때 마다 테스트 클래스의 오브젝트를 새로 만든다 (한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다.)
   => 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만든다.
   
   "픽스쳐(fixture)" : 테스트를 수행하는데 필요한 정보나 오브젝트
   
   2-4 스프링 테스트 적용
   ----------------------------------------------------------------------------